// Generated by gencpp from file gtec_msgs/DWRanging.msg
// DO NOT EDIT!


#ifndef GTEC_MSGS_MESSAGE_DWRANGING_H
#define GTEC_MSGS_MESSAGE_DWRANGING_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace gtec_msgs
{
template <class ContainerAllocator>
struct DWRanging_
{
  typedef DWRanging_<ContainerAllocator> Type;

  DWRanging_()
    : anchorId(0)
    , tagId(0)
    , range(0)
    , rawrange(0)
    , seq(0)
    , maxNoise(0)
    , stdNoise(0)
    , firstPathAmp1(0)
    , firstPathAmp2(0)
    , firstPathAmp3(0)
    , maxGrowthCIR(0)
    , rxPreamCount(0)
    , firstPath(0)
    , channel(0.0)
    , prf(0)
    , datarate(0.0)
    , preambleLength(0)
    , pacSize(0)  {
    }
  DWRanging_(const ContainerAllocator& _alloc)
    : anchorId(0)
    , tagId(0)
    , range(0)
    , rawrange(0)
    , seq(0)
    , maxNoise(0)
    , stdNoise(0)
    , firstPathAmp1(0)
    , firstPathAmp2(0)
    , firstPathAmp3(0)
    , maxGrowthCIR(0)
    , rxPreamCount(0)
    , firstPath(0)
    , channel(0.0)
    , prf(0)
    , datarate(0.0)
    , preambleLength(0)
    , pacSize(0)  {
  (void)_alloc;
    }



   typedef int16_t _anchorId_type;
  _anchorId_type anchorId;

   typedef int16_t _tagId_type;
  _tagId_type tagId;

   typedef int32_t _range_type;
  _range_type range;

   typedef int32_t _rawrange_type;
  _rawrange_type rawrange;

   typedef int32_t _seq_type;
  _seq_type seq;

   typedef int32_t _maxNoise_type;
  _maxNoise_type maxNoise;

   typedef int32_t _stdNoise_type;
  _stdNoise_type stdNoise;

   typedef int32_t _firstPathAmp1_type;
  _firstPathAmp1_type firstPathAmp1;

   typedef int32_t _firstPathAmp2_type;
  _firstPathAmp2_type firstPathAmp2;

   typedef int32_t _firstPathAmp3_type;
  _firstPathAmp3_type firstPathAmp3;

   typedef int32_t _maxGrowthCIR_type;
  _maxGrowthCIR_type maxGrowthCIR;

   typedef int32_t _rxPreamCount_type;
  _rxPreamCount_type rxPreamCount;

   typedef int32_t _firstPath_type;
  _firstPath_type firstPath;

   typedef double _channel_type;
  _channel_type channel;

   typedef int32_t _prf_type;
  _prf_type prf;

   typedef double _datarate_type;
  _datarate_type datarate;

   typedef int32_t _preambleLength_type;
  _preambleLength_type preambleLength;

   typedef int32_t _pacSize_type;
  _pacSize_type pacSize;





  typedef boost::shared_ptr< ::gtec_msgs::DWRanging_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gtec_msgs::DWRanging_<ContainerAllocator> const> ConstPtr;

}; // struct DWRanging_

typedef ::gtec_msgs::DWRanging_<std::allocator<void> > DWRanging;

typedef boost::shared_ptr< ::gtec_msgs::DWRanging > DWRangingPtr;
typedef boost::shared_ptr< ::gtec_msgs::DWRanging const> DWRangingConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gtec_msgs::DWRanging_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gtec_msgs::DWRanging_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::gtec_msgs::DWRanging_<ContainerAllocator1> & lhs, const ::gtec_msgs::DWRanging_<ContainerAllocator2> & rhs)
{
  return lhs.anchorId == rhs.anchorId &&
    lhs.tagId == rhs.tagId &&
    lhs.range == rhs.range &&
    lhs.rawrange == rhs.rawrange &&
    lhs.seq == rhs.seq &&
    lhs.maxNoise == rhs.maxNoise &&
    lhs.stdNoise == rhs.stdNoise &&
    lhs.firstPathAmp1 == rhs.firstPathAmp1 &&
    lhs.firstPathAmp2 == rhs.firstPathAmp2 &&
    lhs.firstPathAmp3 == rhs.firstPathAmp3 &&
    lhs.maxGrowthCIR == rhs.maxGrowthCIR &&
    lhs.rxPreamCount == rhs.rxPreamCount &&
    lhs.firstPath == rhs.firstPath &&
    lhs.channel == rhs.channel &&
    lhs.prf == rhs.prf &&
    lhs.datarate == rhs.datarate &&
    lhs.preambleLength == rhs.preambleLength &&
    lhs.pacSize == rhs.pacSize;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::gtec_msgs::DWRanging_<ContainerAllocator1> & lhs, const ::gtec_msgs::DWRanging_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace gtec_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::gtec_msgs::DWRanging_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gtec_msgs::DWRanging_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gtec_msgs::DWRanging_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gtec_msgs::DWRanging_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gtec_msgs::DWRanging_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gtec_msgs::DWRanging_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gtec_msgs::DWRanging_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9c822fd6a75d14f97f7679d0a373d617";
  }

  static const char* value(const ::gtec_msgs::DWRanging_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9c822fd6a75d14f9ULL;
  static const uint64_t static_value2 = 0x7f7679d0a373d617ULL;
};

template<class ContainerAllocator>
struct DataType< ::gtec_msgs::DWRanging_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gtec_msgs/DWRanging";
  }

  static const char* value(const ::gtec_msgs::DWRanging_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gtec_msgs::DWRanging_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int16 anchorId\n"
"int16 tagId\n"
"int32 range\n"
"int32 rawrange\n"
"int32 seq\n"
"int32 maxNoise\n"
"int32 stdNoise\n"
"int32 firstPathAmp1\n"
"int32 firstPathAmp2\n"
"int32 firstPathAmp3\n"
"int32 maxGrowthCIR\n"
"int32 rxPreamCount\n"
"int32 firstPath\n"
"float64 channel\n"
"int32 prf\n"
"float64 datarate\n"
"int32 preambleLength\n"
"int32 pacSize\n"
;
  }

  static const char* value(const ::gtec_msgs::DWRanging_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gtec_msgs::DWRanging_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.anchorId);
      stream.next(m.tagId);
      stream.next(m.range);
      stream.next(m.rawrange);
      stream.next(m.seq);
      stream.next(m.maxNoise);
      stream.next(m.stdNoise);
      stream.next(m.firstPathAmp1);
      stream.next(m.firstPathAmp2);
      stream.next(m.firstPathAmp3);
      stream.next(m.maxGrowthCIR);
      stream.next(m.rxPreamCount);
      stream.next(m.firstPath);
      stream.next(m.channel);
      stream.next(m.prf);
      stream.next(m.datarate);
      stream.next(m.preambleLength);
      stream.next(m.pacSize);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct DWRanging_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gtec_msgs::DWRanging_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gtec_msgs::DWRanging_<ContainerAllocator>& v)
  {
    s << indent << "anchorId: ";
    Printer<int16_t>::stream(s, indent + "  ", v.anchorId);
    s << indent << "tagId: ";
    Printer<int16_t>::stream(s, indent + "  ", v.tagId);
    s << indent << "range: ";
    Printer<int32_t>::stream(s, indent + "  ", v.range);
    s << indent << "rawrange: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rawrange);
    s << indent << "seq: ";
    Printer<int32_t>::stream(s, indent + "  ", v.seq);
    s << indent << "maxNoise: ";
    Printer<int32_t>::stream(s, indent + "  ", v.maxNoise);
    s << indent << "stdNoise: ";
    Printer<int32_t>::stream(s, indent + "  ", v.stdNoise);
    s << indent << "firstPathAmp1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.firstPathAmp1);
    s << indent << "firstPathAmp2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.firstPathAmp2);
    s << indent << "firstPathAmp3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.firstPathAmp3);
    s << indent << "maxGrowthCIR: ";
    Printer<int32_t>::stream(s, indent + "  ", v.maxGrowthCIR);
    s << indent << "rxPreamCount: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rxPreamCount);
    s << indent << "firstPath: ";
    Printer<int32_t>::stream(s, indent + "  ", v.firstPath);
    s << indent << "channel: ";
    Printer<double>::stream(s, indent + "  ", v.channel);
    s << indent << "prf: ";
    Printer<int32_t>::stream(s, indent + "  ", v.prf);
    s << indent << "datarate: ";
    Printer<double>::stream(s, indent + "  ", v.datarate);
    s << indent << "preambleLength: ";
    Printer<int32_t>::stream(s, indent + "  ", v.preambleLength);
    s << indent << "pacSize: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pacSize);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GTEC_MSGS_MESSAGE_DWRANGING_H
